#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created 14.06.19 15:50

@author: mvb
"""
import tensorflow as tf
import numpy as np
from learned_model.ml_models.mlp_keras import MultiLayerPerceptron
from learned_model_for_mpc.ml_models.mlp_keras_sparse_mpc import MultiLayerPerceptronMPCSparse
import time
from simulator.model.dynamic_mpc_model import DynamicVehicleMPC
from simulator.model.kinematic_mpc_model import KinematicVehicleMPC
from numpy import sin, cos, tan, pi


class NoModelSparseModel:
    def __init__(self, model_type='mlp', model_name='FirstTry'):
        self.model_type = model_type
        self.model_name = model_name
        self.direct_input = True
        # Load the NN
        # if self.direct_input:
        #     mlp = MultiLayerPerceptronMPCSparse(model_name=model_name)
        # else:
        #     raise ValueError('Invalid configuration: has to be direct input!')
        # self.mlp.load_model()
        # # self.mlp.load_checkpoint('best')
        # self.weights, self.biases = self.mlp.get_weights()

        if model_name == '0x1503_None_reg0p0001_100ksample_powerexpotrigopoly2_l1sparse_directinput':
            self.predictor = self.NN_1 #completely unstable (nans)
        elif model_name ==  '0x966_None_reg0p0001_50ksample_expotrigocustompoly2_l1sparse_directinput':
            self.predictor = self.NN_2 # unstable because of x/(vx+0.5) --> singularity at vx+0.5 = 0
        elif model_name ==  '0x426_None_reg0p0001_50ksample_expotrigopoly2_l1sparse_directinput':
            self.predictor = self.NN_3 # unstable because of tan(something > pi/3) --> singularity at pi/2
        elif model_name ==  '0x369_None_reg0p0001_50ksample_expotrigopoly2_l1sparse_directinput':
            self.predictor = self.NN_4 #unstable in drift
        elif model_name ==  '0x2161_None_reg0p0001_50ksample_expotrigopoly3_l1sparse_directinput':
            self.predictor = self.NN_5 #unstable in drift
        elif model_name == 'poly3_order1':
            self.predictor = self.NN_poly3_order1 #stable but unrealistic
        elif model_name == 'poly3_order2':
            self.predictor = self.NN_poly3_order2 #stable but unrealistic (missing coupling(vx*vtheta) term in ay); largest improvement for ax
        elif model_name == 'poly3_order3':
            self.predictor = self.NN_poly3_order3 #stable and more realistic in vy but still not quickly convergent to 0
        elif model_name == 'poly3_order4':
            # self.predictor = self.NN_poly3_order4 # but unstable when driving backwards and when braking! first appearance of TV in atheta, more realistic drifting, no deceleration after vx=0
            self.predictor = self.NN_poly3_order34 # with ay from poly3_order3
        elif model_name == 'poly3_order5':
            self.predictor = self.NN_poly3_order5 # first coupling term in ay (vx*vtheta)
        # conclusion: too many counter acting terms! e.g. Ay' combo of 1st 3rd terms in order_4 --> try same with poly2!
        elif model_name == 'poly2_order2':
            self.predictor = self.NN_poly2_order2 #stable but unrealistic in vy (no 0-equilibrium)
        elif model_name == 'poly2_order3':
            self.predictor = self.NN_poly2_order3 #stable but no drifting (kinematicish)
        elif model_name == 'poly2_order4':
            # self.predictor = self.NN_poly2_order4 #unstable in vy (2nd term in AY is baaaad!)
            self.predictor = self.NN_poly2_order34 #without 2nd term in AY; very unrealistic drifting! but stable
        elif model_name == 'poly2_order5':
            self.predictor = self.NN_poly2_order5 #stable, but unrealistic cornering/drifting (very high speeds in small circles possible)
        elif model_name == 'poly2_order6':
            self.predictor = self.NN_poly2_order6 #stable, but unrealistic cornering/drifting (little bit better as poly2_order5)

        # # Load parameters for normalizing inputs
        # self.means, self.stds = mlp.get_normalizing_parameters()

    def get_name(self):
        return self.model_type

    def get_direct_input_mode(self):
        return self.direct_input

    def normalize_input(self, input):
        return (input - self.means) / self.stds

    def get_accelerations(self, initial_velocities=[0, 0, 0], system_inputs=[0, 0, 0, 0]):
        if isinstance(initial_velocities, list):
            features = [initial_velocities + system_inputs]

            # normalized_features = self.normalize_input(features)
            prediction = self.predictor(features)

            result = prediction

            return result
        else:
            input = np.hstack((initial_velocities, system_inputs))
            # prediction = self.mlp.predict(input)
            prediction = self.predictor(input)
            result = prediction
            return result

    def NN_1(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = x = 0.4603191316127777 * ((VY) * (sin(VTHETA/2.8)) - -0.00016034240796200001) / 0.203489363594797 + 0.6833432912826538 * ((AB) * (cos(VTHETA/2.8)) - 0.060848109413071) / 0.7735066733194108
        AY = 0.570935070514679 * ((VTHETA) * (cos(VTHETA/2.8)) - -0.038525348589536004) / 0.447220225881681 + 0.3632095456123352 * ((BETA) * (np.power(1/2.0,VX)) - -0.009680760981202) / 0.073958974545858 + 0.5363375544548035 * ((BETA) * (sin(VX/10.0)) - -0.008098287892864) / 0.08460266910535201 + 0.48927992582321167 * ((np.power(VX,1/2.0)) * (sin(VTHETA/2.8)) - -0.043843214273553) / 0.56696763948067 + 0.3547237813472748 * ((np.power(VTHETA,1/2.0)) * (tan(BETA/0.44)) - -0.04613413804778599) / 0.4829364908451021 + 0.33688849210739136 * ((np.power(2,VX)) * (sin(BETA/0.44)) - -2.48683676868027) / 36.8043348758579 + 0.573861837387085 * ((sin(VX/10.0)) * (sin(VTHETA/2.8)) - -0.012085480018517999) / 0.171140538638766 + -0.34185951948165894 * (tan(BETA/0.44) - -0.07561438539503301) / 0.597289198717473 + -0.9311690330505371 * ((VX) * (tan(VTHETA/2.8)) - -0.07401354555366099) / 1.03974972704751 + -0.3448571562767029 * ((BETA) * (np.power(2,VX)) - -0.793713076733508) / 11.761784832478199 + -0.5715564489364624 * ((BETA) * (cos(VX/10.0)) - -0.024378942707270004) / 0.18276404064361104 + -0.3508402705192566 * ((sin(VY/4.0)) * (cos(VTHETA/2.8)) - -0.0006887277807849999) / 0.077774101845164 + -0.8108291029930115 * ((tan(VX/10.0)) * (tan(VTHETA/2.8)) - -0.009028684032665001) / 0.12422855083467402 + -0.3431820273399353 * ((tan(VX/10.0)) * (tan(BETA/0.44)) - -0.018575928625103) / 0.202350137864482
        ATHETA = 0.5382707715034485 * ((VX) * (sin(BETA/0.44)) - -0.17354558419594698) / 1.8348571394437398 + 0.4051479995250702 * ((VTHETA) * (np.power(VTHETA,1/2.0)) - -0.042551434279232005) / 0.591720053085284 + 0.7295905947685242 * ((BETA) * (cos(VY/4.0)) - -0.026669719375825005) / 0.19966769234944298 + 0.5879685282707214 * ((BETA) * (cos(VTHETA/2.8)) - -0.025129667555557997) / 0.186820628104118 + 0.5314434170722961 * ((TV) * (np.power(BETA,1/2.0)) - -0.030408345862288) / 0.308483414991109 + 0.7143911123275757 * ((np.power(VY,1/2.0)) * (sin(VTHETA/2.8)) - -0.014090644411631999) / 0.18279429729107197 + 0.63498455286026 * ((sin(VX/10.0)) * (sin(BETA/0.44)) - -0.024304227284302996) / 0.251942611078135 + 0.4778699278831482 * ((sin(VX/10.0)) * (sin(TV/2.1)) - -0.020067552216055) / 0.22540137808232102 + 0.5671713948249817 * ((sin(BETA/0.44)) * (cos(VY/4.0)) - -0.08104217623647501) / 0.585849648707563 + 0.47807973623275757 * ((sin(BETA/0.44)) * (tan(VX/10.0)) - -0.019643038508436) / 0.21121408271731698 + -0.47983983159065247 * (sin(VTHETA/2.8) - -0.023185919378872002) / 0.27000042943615304 + -0.5720016956329346 * ((VTHETA) * (cos(VX/10.0)) - -0.035363640816025006) / 0.42257761518934994 + -0.9915497899055481 * ((VTHETA) * (cos(VTHETA/2.8)) - -0.038525348589536004) / 0.447220225881681 + -0.5007932782173157 * ((np.power(VX,1/2.0)) * (sin(VTHETA/2.8)) - -0.043843214273553) / 0.56696763948067 + -0.6960859894752502 * ((np.power(VY,1/2.0)) * (sin(BETA/0.44)) - -0.026948253203865) / 0.286011011569735 + -0.325606107711792 * ((np.power(2,VX)) * (tan(BETA/0.44)) - -2.1492022460052698) / 31.920576211346898 + -0.6208920478820801 * ((np.power(1/2.0,VX)) * (sin(BETA/0.44)) - -0.029775231284707993) / 0.213768953708817 + -0.5824641585350037 * ((sin(VTHETA/2.8)) * (cos(VX/10.0)) - -0.017622532280788996) / 0.209026608655621 + -0.36669114232063293 * ((sin(VTHETA/2.8)) * (cos(AB/6.7)) - -0.021871954172744002) / 0.251828918573614 + -0.5751466155052185 * ((cos(VX/10.0)) * (tan(TV/2.1)) - -0.032895439748777004) / 0.302784156039877
        return [AX, AY, ATHETA]

    def NN_2(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = 0.4564538300037384 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + 0.3948417603969574 * ((AB) * (cos(VY/(VX+0.5))) - 0.06362373075964102) / 0.8257941982944974 + 0.29931679368019104 * ((sin(AB/6.7*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - 0.015982801020785392) / 0.16354570224492368
        AY = 0.6020984053611755 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + 0.46501028537750244 * ((np.power(2,VX)) * (sin(VTHETA/2.8*pi/2.0)) - -2.471101283196555) / 33.39617506284521 + 0.3437266945838928 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.018884194257144826) / 0.22788034150027564 + 0.3012744188308716 * ((cos(VX/10.0*pi/2.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.014233656202114125) / 0.1681074005888865 + -0.31655219197273254 * ((VX) * (tan(VTHETA/2.8*pi/3.0)) - -0.08172319595383827) / 1.129029651289001 + -0.47648218274116516 * ((np.power(2,VX)) * (tan(VTHETA/2.8*pi/3.0)) - -1.9679480798557931) / 26.23276243479074 + -0.31909263134002686 * ((np.power(1/2.0,VX)) * (sin(VTHETA/2.8*pi/2.0)) - -0.004141990298728557) / 0.04192766159473326 + -0.2728832960128784 * ((sin(VX/10.0*pi/2.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.01085092358604598) / 0.15178510121683414 + -0.3507033884525299 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + -0.53174889087677 * ((tan(VX/10.0*pi/3.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.01039103519146144) / 0.14032661579675312
        ATHETA = 0.39695119857788086 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + 0.2761979401111603 * ((BETA) * (AB) - 0.006754610408016997) / 0.16145230468338204 + 0.6902493834495544 * ((BETA) * (cos(VY/4.0*pi/2.0)) - -0.02714613390458211) / 0.19928757515487344 + 0.4875805974006653 * ((BETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.025355996620780943) / 0.18491002204225712 + 0.3270367681980133 * ((TV) * (sin(VX/10.0*pi/2.0)) - -0.03227141486642634) / 0.3619096299890321 + 0.3129788935184479 * ((np.power(2,VX)) * (sin(VY/4.0*pi/2.0)) - 0.6781794907220625) / 13.617388867747891 + 0.23541316390037537 * ((np.power(2,VX)) * (tan(VTHETA/2.8*pi/3.0)) - -1.9679480798557931) / 26.23276243479074 + 0.2768270969390869 * ((np.power(2,AB)) * (sin(VTHETA/(VX+0.5))) - -0.010899502693916029) / 0.2032871691884402 + 0.458028107881546 * ((np.power(1/2.0,VX)) * (sin(BETA/(VX+0.5))) - -0.008654938455651292) / 0.07894216743066748 + 0.2767094671726227 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - -0.02551175347595281) / 0.2586397131882021 + 0.2522534430027008 * ((sin(VX/10.0*pi/2.0)) * (sin(TV/2.1*pi/2.0)) - -0.02145839908222999) / 0.22935592734229465 + 1.0027167797088623 * ((sin(BETA/0.44*pi/2.0)) * (cos(VY/4.0*pi/2.0)) - -0.08252919863814337) / 0.5861029473951472 + 0.6497592926025391 * ((sin(BETA/0.44*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0777132483846258) / 0.5471377317941282 + 0.2847153842449188 * ((sin(BETA/0.44*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.020904650196453264) / 0.22045920739339014 + 0.38029760122299194 * ((cos(VY/4.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07733019208454321) / 0.5959618170976972 + 0.3173882067203522 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07153558128985435) / 0.5495175413687395 + -0.6818062663078308 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + -0.385374516248703 * ((BETA) * (np.power(2,AB)) - -0.022623004571397626) / 0.2738623831313397 + -0.38489705324172974 * ((BETA) * (cos(VX/10.0*pi/2.0)) - -0.024704062525574985) / 0.18168279235643928 + -0.7171915173530579 * ((np.power(1/2.0,VX)) * (sin(BETA/0.44*pi/2.0)) - -0.030163300769992137) / 0.2143286512200165 + -0.31640952825546265 * ((sin(VY/4.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - 0.00018074893102826308) / 0.07596603887730569 + -0.30783483386039734 * ((sin(VTHETA/2.8*pi/2.0)) * (sin(AB/6.7*pi/2.0)) - 0.003930745741995025) / 0.07175021986310852 + -0.6191495060920715 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VY/4.0*pi/2.0)) - -0.02385202353752686) / 0.2761283859649823 + -0.4075581133365631 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.01322565069008556) / 0.1754050371597621 + -0.2578926384449005 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.0245766909548577) / 0.2764467422327574 + -0.2869473099708557 * ((sin(BETA/0.44*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.07521730088896078) / 0.5323951275355917 + -0.2971489727497101 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.015024997637238103) / 0.17205301847137705 + -0.3018857538700104 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(TV/2.1*pi/3.0)) - -0.038665583065579115) / 0.3277826162422308 + -0.3214239776134491 * ((cos(VTHETA/2.8*pi/2.0)) * (sin(VTHETA/(VX+0.5))) - -0.012842266255106037) / 0.12629431268594474 + -0.32813289761543274 * ((cos(AB/6.7*pi/2.0)) * (sin(BETA/(VX+0.5))) - -0.015651906918326772) / 0.11301672768099785 + -0.37470218539237976 * ((cos(AB/6.7*pi/2.0)) * (tan(BETA/(VX+0.5))) - -0.016342173948436012) / 0.12223928846592835 + -0.4652920067310333 * ((tan(BETA/0.44*pi/3.0)) * (cos(BETA/(VX+0.5))) - -0.07620329022821991) / 0.5907036906528708
        return [AX, AY, ATHETA]

    def NN_3(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = 0.35094383358955383 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + 0.43716341257095337 * ((VTHETA) * (sin(VY/4.0*pi/2.0)) - -0.0006972868825660423) / 0.15607772388276112 + 0.34249913692474365 * ((sin(AB/6.7*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - 0.015982801020785392) / 0.16354570224492368
        AY = 0.3196723163127899 * ((VY) * (tan(VX/10.0*pi/3.0)) - 0.005144678661245813) / 0.20226677927976314 + 0.45810773968696594 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + 0.28134405612945557 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.015024997637238103) / 0.17205301847137705 + -0.34145915508270264 * ((VX) * (tan(VTHETA/2.8*pi/3.0)) - -0.08172319595383827) / 1.129029651289001 + -0.25880756974220276 * ((VY) * (cos(VTHETA/2.8*pi/2.0)) - -0.003004566875997632) / 0.22218493964294675 + -0.34661510586738586 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + -0.3718077540397644 * ((tan(VX/10.0*pi/3.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.01039103519146144) / 0.14032661579675312
        ATHETA = 0.36211836338043213 * ((VX) * (BETA) - -0.059164368850320524) / 0.616404092345298 + 0.514701247215271 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + 0.3678813576698303 * ((sin(TV/2.1*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.01846512064218174) / 0.2049342834902831 + 0.38403478264808655 * ((cos(VY/4.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07733019208454321) / 0.5959618170976972 + 0.2902410328388214 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07153558128985435) / 0.5495175413687395 + -0.44832202792167664 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + -0.3222391605377197 * ((np.power(1/2.0,VX)) * (sin(BETA/0.44*pi/2.0)) - -0.030163300769992137) / 0.2143286512200165 + -0.34659361839294434 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VY/4.0*pi/2.0)) - -0.02385202353752686) / 0.2761283859649823 + -0.3173779547214508 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.0245766909548577) / 0.2764467422327574 + -0.36302658915519714 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(VTHETA/2.8*pi/3.0)) - -0.015024997637238103) / 0.17205301847137705
        return [AX, AY, ATHETA]

    def NN_4(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = 0.4680481255054474 * ((VY) * (sin(VTHETA/2.8*pi/2.0)) - 0.0002793378374379906) / 0.21241401778579333 + 0.3283174932003021 * ((AB) * (cos(AB/6.7*pi/2.0)) - 0.09004761758274568) / 0.6524575764588124 + 0.36154770851135254 * ((sin(AB/6.7*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.02203966103905764) / 0.1666718588702699 + 0.0032634250819683075
        AY = 0.30168119072914124 * ((VY) * (tan(VX/10.0*pi/3.0)) - 0.005144678661245813) / 0.20226677927976314 + 0.7358527183532715 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + -0.36956802010536194 * ((VX) * (VTHETA) - -0.19631195879670152) / 2.706649563739692 + -0.3289470374584198 * ((VTHETA) * (tan(VX/10.0*pi/3.0)) - -0.024984063549927302) / 0.3369705692353521 + -0.5665939450263977 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + 0.0017183783929795027
        ATHETA = 0.43306776881217957 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + 0.42917078733444214 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - -0.02551175347595281) / 0.2586397131882021 + 0.36551257967948914 * ((sin(VX/10.0*pi/2.0)) * (sin(TV/2.1*pi/2.0)) - -0.02145839908222999) / 0.22935592734229465 + 0.3637049198150635 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + 0.35362061858177185 * ((sin(BETA/0.44*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.020904650196453264) / 0.22045920739339014 + -0.6597894430160522 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + -0.3602469861507416 * ((sin(VY/4.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - 0.00018074893102826308) / 0.07596603887730569 + -0.36134228110313416 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.018802793215748483) / 0.21827548715590472 + -0.48776328563690186 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.01322565069008556) / 0.1754050371597621 + 0.001592446118593216
        test_AY = [0.30168119072914124 * ((VY) * (tan(VX/10.0*pi/3.0)) - 0.005144678661245813) / 0.20226677927976314,
                   0.7358527183532715 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155,
                   -0.36956802010536194 * ((VX) * (VTHETA) - -0.19631195879670152) / 2.706649563739692,
                   -0.3289470374584198 * ((VTHETA) * (tan(VX/10.0*pi/3.0)) - -0.024984063549927302) / 0.3369705692353521,
                   -0.5665939450263977 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646,
                   0.0017183783929795027]
        test_ATHETA = [0.43306776881217957 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332, 0.42917078733444214 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - -0.02551175347595281) / 0.2586397131882021, 0.36551257967948914 * ((sin(VX/10.0*pi/2.0)) * (sin(TV/2.1*pi/2.0)) - -0.02145839908222999) / 0.22935592734229465, 0.3637049198150635 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646, 0.35362061858177185 * ((sin(BETA/0.44*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.020904650196453264) / 0.22045920739339014, -0.6597894430160522 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155, -0.3602469861507416 * ((sin(VY/4.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - 0.00018074893102826308) / 0.07596603887730569, -0.36134228110313416 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.018802793215748483) / 0.21827548715590472, -0.48776328563690186 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.01322565069008556) / 0.1754050371597621, 0.001592446118593216]
        # for p in test_AY:
        #     print(p)
        return [AX, AY, ATHETA]

    def NN_42(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = 0.15435791015625 * ((VX) * (cos(BETA/0.44*pi/2.0)) - 2.086206577040916) / 1.7625891197618575 + 0.43065813183784485 * ((VY) * (sin(VTHETA/2.8*pi/2.0)) - 0.0002793378374379906) / 0.21241401778579333 + 0.1722385585308075 * ((AB) * (cos(AB/6.7*pi/2.0)) - 0.09004761758274568) / 0.6524575764588124 + 0.17291118204593658 * ((np.power(2,AB)) * (cos(VTHETA/2.8*pi/2.0)) - 1.1411945334957767) / 0.6488461936504178 + 0.19718347489833832 * ((sin(AB/6.7*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.02203966103905764) / 0.1666718588702699 + 0.2072509378194809 * ((cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - 0.8612734250602802) / 0.1821624136846708 + 0.18138231337070465 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(AB/6.7*pi/3.0)) - 0.007566748027649632) / 0.1380581859529477 + 0.0031905570067465305
        AY = 0.14196883141994476 * (sin(VTHETA/2.8*pi/2.0) - -0.025037709771398083) / 0.2855931945667471 + 0.1740206629037857 * ((VY) * (np.power(1/2.0,VX)) - 0.0007437089541237603) / 0.04139564265858714 + 0.21440893411636353 * ((VY) * (tan(VX/10.0*pi/3.0)) - 0.005144678661245813) / 0.20226677927976314 + 0.5407888293266296 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + 0.15404339134693146 * ((np.power(2,VX)) * (sin(BETA/0.44*pi/2.0)) - -2.597021810646166) / 37.75541853730042 + 0.16354438662528992 * ((sin(VX/10.0*pi/2.0)) * (sin(VY/4.0*pi/2.0)) - 0.0008346790324208383) / 0.07556442925006827 + 0.17393597960472107 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - -0.02551175347595281) / 0.2586397131882021 + 0.1588076800107956 * ((sin(VY/4.0*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - 0.0016613623243246596) / 0.07151192873588606 + 0.17587067186832428 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.018802793215748483) / 0.21827548715590472 + 0.18808157742023468 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.0245766909548577) / 0.2764467422327574 + -0.3307395279407501 * ((VX) * (VTHETA) - -0.19631195879670152) / 2.706649563739692 + -0.24217185378074646 * ((VY) * (cos(VTHETA/2.8*pi/2.0)) - -0.003004566875997632) / 0.22218493964294675 + -0.14583459496498108 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + -0.1535557061433792 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + -0.23100197315216064 * ((VTHETA) * (tan(VX/10.0*pi/3.0)) - -0.024984063549927302) / 0.3369705692353521 + -0.1925353705883026 * ((BETA) * (cos(AB/6.7*pi/2.0)) - -0.027110579074017) / 0.1981934581539346 + -0.13503722846508026 * ((BETA) * (tan(VX/10.0*pi/3.0)) - -0.006927802459959079) / 0.07331567891700316 + -0.17063003778457642 * ((np.power(2,VX)) * (tan(BETA/0.44*pi/3.0)) - -2.2649890541305164) / 32.843702597666486 + -0.48174849152565 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + -0.15246352553367615 * ((sin(VY/4.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.00033021699690999) / 0.0939663123704857 + 0.0018923563184216619
        ATHETA = 0.19319984316825867 * ((VX) * (TV) - -0.2317972077113321) / 2.6490140417448003 + 0.3356429934501648 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + 0.1386985182762146 * ((TV) * (tan(VX/10.0*pi/3.0)) - -0.028058412762629863) / 0.3280168713316988 + 0.30660927295684814 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - -0.02551175347595281) / 0.2586397131882021 + 0.1883859485387802 * ((sin(VX/10.0*pi/2.0)) * (sin(TV/2.1*pi/2.0)) - -0.02145839908222999) / 0.22935592734229465 + 0.3193257749080658 * ((sin(VY/4.0*pi/2.0)) * (cos(VTHETA/2.8*pi/2.0)) - -0.0014379335184869313) / 0.08193942338281646 + 0.1742919385433197 * ((sin(VY/4.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.0004309053578922326) / 0.10422615607165543 + 0.38902056217193604 * ((sin(BETA/0.44*pi/2.0)) * (cos(VY/4.0*pi/2.0)) - -0.08252919863814337) / 0.5861029473951472 + 0.3065260946750641 * ((sin(BETA/0.44*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.020904650196453264) / 0.22045920739339014 + 0.19314080476760864 * ((cos(VTHETA/2.8*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07153558128985435) / 0.5495175413687395 + 0.22777706384658813 * ((cos(BETA/0.44*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.04171116101243709) / 0.2943814825202627 + 0.16412942111492157 * ((cos(AB/6.7*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.07715922437089713) / 0.5928592700526455 + 0.17442747950553894 * ((tan(VX/10.0*pi/3.0)) * (tan(TV/2.1*pi/3.0)) - -0.01600544101398789) / 0.1995590527023137 + -0.21812476217746735 * ((VY) * (cos(VX/10.0*pi/2.0)) - -0.003216463910703705) / 0.21981376130711971 + -0.13826234638690948 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + -0.15388575196266174 * ((VTHETA) * (cos(VY/4.0*pi/2.0)) - -0.04548451961924524) / 0.5302013742863676 + -0.5656466484069824 * ((VTHETA) * (cos(VTHETA/2.8*pi/2.0)) - -0.03819202015541585) / 0.4358460110908155 + -0.18473264575004578 * ((TV) * (cos(VTHETA/2.8*pi/2.0)) - -0.07104934547858993) / 0.5726397422086099 + -0.16557100415229797 * ((np.power(2,VX)) * (tan(TV/2.1*pi/3.0)) - -2.4759847786317444) / 46.232339550042035 + -0.42241406440734863 * ((np.power(1/2.0,VX)) * (sin(BETA/0.44*pi/2.0)) - -0.030163300769992137) / 0.2143286512200165 + -0.4073941111564636 * ((sin(VY/4.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - 0.00018074893102826308) / 0.07596603887730569 + -0.29245245456695557 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.018802793215748483) / 0.21827548715590472 + -0.16879962384700775 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(VY/4.0*pi/2.0)) - -0.02385202353752686) / 0.2761283859649823 + -0.42160600423812866 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.01322565069008556) / 0.1754050371597621 + -0.18338744342327118 * ((sin(VTHETA/2.8*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.0245766909548577) / 0.2764467422327574 + 0.00016012051491998136
        return [AX, AY, ATHETA]

    def NN_5(self, features):
        VX, VY, VTHETA, BETA, AB, TV = features[0]
        VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        AX = 0.2659534513950348 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + 0.22231623530387878 * ((np.power(1/2.0,VX)) * (tan(AB/6.7*pi/3.0)) - -0.00010768341378417941) / 0.04873519711370335 + 0.19656914472579956 * ((VY) * (VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.024332061026586426) / 0.3425095661955139 + 0.20274315774440765 * ((np.power(1/2.0,VX)) * (cos(AB/6.7*pi/2.0)) * (tan(AB/6.7*pi/3.0)) - 0.0013867295112498135) / 0.032494593373706096 + 0.1792829930782318 * ((sin(VX/10.0*pi/2.0)) * (sin(VX/10.0*pi/2.0)) * (sin(AB/6.7*pi/2.0)) - 0.011459337429086898) / 0.09803724672565498 + 0.2324194759130478 * ((cos(BETA/0.44*pi/2.0)) * (cos(TV/2.1*pi/2.0)) * (tan(AB/6.7*pi/3.0)) - 0.009019382506809172) / 0.11771036911425642 + 0.26565849781036377 * ((cos(AB/6.7*pi/2.0)) * (cos(TV/2.1*pi/2.0)) * (tan(AB/6.7*pi/3.0)) - 0.016444797322635714) / 0.09981639381993536 + -0.1872621476650238 * ((AB) * (np.power(1/2.0,VX)) * (np.power(1/2.0,VX)) - 0.0020386582544514253) / 0.1969864325935936 + -0.1971777379512787 * ((np.power(1/2.0,VX)) * (np.power(1/2.0,VX)) * (sin(AB/6.7*pi/2.0)) - 0.0008076561179434566) / 0.041461304199074935 + 0.0033549817744642496
        AY = 0.16367846727371216 * ((VX) * (BETA) * (cos(TV/2.1*pi/2.0)) - -0.0454614197574927) / 0.4918981504195246 + 0.25669583678245544 * ((VY) * (VTHETA) * (VTHETA) - 0.026297031571554143) / 0.8483148589544969 + 0.1859508454799652 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.030270735736605683) / 0.3437613897979791 + 0.20848315954208374 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.035280427803722585) / 0.406522412395136 + -0.1833256483078003 * ((VX) * (VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.14028067622764712) / 2.138399221182964 + -0.23361606895923615 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.004006374758909815) / 0.17575600464338803 + -0.2905295491218567 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.003290577280095432) / 0.21026023128849894 + -0.31103649735450745 * ((VTHETA) * (VTHETA) * (VTHETA) - -0.06823344395446589) / 1.1956058156183735 + 0.0006194222369231284
        ATHETA = 0.20895038545131683 * ((VX) * (BETA) * (cos(VX/10.0*pi/2.0)) - -0.044562332862094906) / 0.4477261272339822 + 0.28732144832611084 * ((VX) * (BETA) * (cos(BETA/0.44*pi/2.0)) - -0.03265936908102456) / 0.35647500616315275 + 0.2518816888332367 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.13355719270727873) / 1.3269321982864386 + 0.19312980771064758 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + 0.18858037889003754 * ((VX) * (cos(BETA/0.44*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.08720619501258484) / 0.9478559672529776 + 0.1609167605638504 * ((VY) * (VY) * (tan(BETA/0.44*pi/3.0)) - -0.005202238391795624) / 0.4447171727544636 + 0.2523990571498871 * ((VY) * (VTHETA) * (sin(BETA/0.44*pi/2.0)) - 0.003081009539086496) / 0.3287846361134036 + 0.5518845319747925 * ((VTHETA) * (VTHETA) * (VTHETA) - -0.06823344395446589) / 1.1956058156183735 + 0.26805195212364197 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.004660552573646553) / 0.04956558064052531 + 0.166082963347435 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.00838205150499778) / 0.0837798746661463 + 0.19550065696239471 * ((BETA) * (cos(VX/10.0*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.004883585395754023) / 0.05021360291341599 + 0.26680320501327515 * ((TV) * (sin(VX/10.0*pi/2.0)) * (sin(VX/10.0*pi/2.0)) - -0.018286674049614825) / 0.2557357204626517 + 0.17141398787498474 * ((sin(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.02414463211879956) / 0.2455405550861403 + -0.23680467903614044 * (VTHETA - -0.04802685383934488) / 0.5524821241332127 + -0.2592310309410095 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + -0.17863944172859192 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + -0.2584174573421478 * ((VX) * (VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.11037305531147268) / 1.6612881360540883 + -0.2389737218618393 * ((VY) * (cos(BETA/0.44*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - 0.0009155776943812488) / 0.1777622096415573 + -0.2108752429485321 * ((VTHETA) * (TV) * (sin(TV/2.1*pi/2.0)) - -0.02903973179873526) / 0.4396385361281073 + -0.2210875004529953 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.01852756225848957) / 0.2936395801610952 + -0.330038458108902 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.030270735736605683) / 0.3437613897979791 + -0.24120938777923584 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) * (cos(BETA/0.44*pi/2.0)) - -0.017679153667653255) / 0.2419644280503981 + -0.19940927624702454 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.024533058035904626) / 0.3227320389025673 + -0.21756085753440857 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.035840663314485044) / 0.4226868268268192 + -0.21499040722846985 * ((VTHETA) * (cos(TV/2.1*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - -0.017615116044736846) / 0.2720124487829442 + 0.00041167877498082817
        return [AX, AY, ATHETA]

    def NN_poly3_order1(self, features):
        if isinstance(features,list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.7006953358650208 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + 0.0011560311540961266
        AY = -0.21208234131336212 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + 0.0012900797883048654
        ATHETA = 0.3357184827327728 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + 0.004603125620633364
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly3_order2(self, features):
        if isinstance(features,list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.7030048370361328 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + \
             0.4560210704803467 * ((VY) * (VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.0034241363837385448) / 0.4297752996153552 + \
             0.0034161685034632683
        AY = 0.2787986099720001 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.00658344568162781) / 0.06916596921843254 + \
             -0.437671422958374 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + \
             0.0031603968236595392
        ATHETA = 1.2613248825073242 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + \
                 -1.1857154369354248 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + \
                 0.0002638384758029133
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly3_order3(self, features):
        if isinstance(features,list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5648834109306335 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + \
             0.4587765634059906 * ((VY) * (VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.0034241363837385448) / 0.4297752996153552 + \
             0.14884346723556519 * ((AB) * (cos(BETA/0.44*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.06667145440980085) / 0.6568028772547091 + \
             0.003673602594062686
        AY = 0.40896862745285034 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.00658344568162781) / 0.06916596921843254 + \
             -0.1548536717891693 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.003290577280095432) / 0.21026023128849894 + \
             -0.5412811636924744 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + \
             0.002542872680351138
        ATHETA = 1.2758663892745972 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + \
                 -0.8191916346549988 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + \
                 -0.4189247786998749 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.024533058035904626) / 0.3227320389025673 + \
                 0.0010417811572551727
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly3_order4(self, features):
        if isinstance(features,list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]

        AX = 0.5782973766326904 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + \
             0.4590094983577728 * ((VY) * (VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.0034241363837385448) / 0.4297752996153552 + \
             0.17996183037757874 * ((AB) * (cos(BETA/0.44*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.06667145440980085) / 0.6568028772547091 + \
             -0.11006134003400803 * ((np.power(1/2.0,VX)) * (np.power(1/2.0,VX)) * (tan(AB/6.7*pi/3.0)) - 1.4022951669001227e-05) / 0.0359719031099005 + \
             0.004805603064596653
        # Ay' 1st term is baaad! (linear growing of vy!)
        AY = 0.3868822753429413 * ((VY) * (VTHETA) * (VTHETA) - 0.026297031571554143) / 0.8483148589544969 + \
             0.5623955726623535 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.00658344568162781) / 0.06916596921843254 + \
             -0.472157746553421 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.003290577280095432) / 0.21026023128849894 + \
             -0.5448050498962402 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + \
             0.001445370027795434
        ATHETA = 1.1056407690048218 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + \
                 0.3074852228164673 * ((TV) * (sin(VX/10.0*pi/2.0)) * (sin(VX/10.0*pi/2.0)) - -0.018286674049614825) / 0.2557357204626517 + \
                 -0.8313732147216797 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + \
                 -0.43447065353393555 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.024533058035904626) / 0.3227320389025673 + \
                 0.0009256743942387402
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly3_order34(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5648834109306335 * (sin(AB / 6.7 * pi / 2.0) - 0.017419083821411975) / 0.1785014463024927 + \
             0.4587765634059906 * ((VY) * (VTHETA) * (cos(AB / 6.7 * pi / 2.0)) - -0.0034241363837385448) / 0.4297752996153552 + \
             0.14884346723556519 * ((AB) * (cos(BETA / 0.44 * pi / 2.0)) * (cos(TV / 2.1 * pi / 2.0)) - 0.06667145440980085) / 0.6568028772547091 + \
             0.003673602594062686
        AY = 0.5623955726623535 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.00658344568162781) / 0.06916596921843254 + \
             -0.472157746553421 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.003290577280095432) / 0.21026023128849894 + \
             -0.5448050498962402 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + \
             0.001445370027795434
        ATHETA = 1.1056407690048218 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + \
                 0.3074852228164673 * ((TV) * (sin(VX/10.0*pi/2.0)) * (sin(VX/10.0*pi/2.0)) - -0.018286674049614825) / 0.2557357204626517 + \
                 -0.8313732147216797 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + \
                 -0.43447065353393555 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.024533058035904626) / 0.3227320389025673 + \
                 0.0009256743942387402
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly3_order5(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5192764401435852 * (sin(AB/6.7*pi/2.0) - 0.017419083821411975) / 0.1785014463024927 + \
             0.4466239809989929 * ((VY) * (VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.0034241363837385448) / 0.4297752996153552 + \
             0.15367157757282257 * ((AB) * (cos(BETA/0.44*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - 0.06667145440980085) / 0.6568028772547091 + \
             -0.11462798714637756 * ((np.power(1/2.0,VX)) * (np.power(1/2.0,VX)) * (tan(AB/6.7*pi/3.0)) - 1.4022951669001227e-05) / 0.0359719031099005 + \
             -0.09629638493061066 * ((sin(VX/10.0*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) * (sin(BETA/0.44*pi/2.0)) - 0.13253847684534972) / 0.15639161518495984 + \
             0.0035659153945744038
        AY = 0.4510933458805084 * ((VY) * (VTHETA) * (VTHETA) - 0.026297031571554143) / 0.8483148589544969 + \
             0.25826212763786316 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) * (cos(VX/10.0*pi/2.0)) - -0.030270735736605683) / 0.3437613897979791 + \
             0.2908010482788086 * ((BETA) * (sin(VX/10.0*pi/2.0)) * (cos(TV/2.1*pi/2.0)) - -0.00658344568162781) / 0.06916596921843254 + \
             -0.5229536890983582 * ((VY) * (cos(VX/10.0*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.003290577280095432) / 0.21026023128849894 + \
             -0.4445132911205292 * ((np.power(2,VX)) * (cos(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.6083722018073039) / 9.481076711683418 + \
             0.0011405212571844459
        ATHETA = 0.27089810371398926 * ((VX) * (BETA) * (cos(VX/10.0*pi/2.0)) - -0.044562332862094906) / 0.4477261272339822 + \
                 0.9628204107284546 * ((VX) * (sin(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.17553810801460182) / 1.772763941713415 + \
                 0.32429030537605286 * ((TV) * (sin(VX/10.0*pi/2.0)) * (sin(VX/10.0*pi/2.0)) - -0.018286674049614825) / 0.2557357204626517 + \
                 -1.0676026344299316 * ((VTHETA) * (cos(AB/6.7*pi/2.0)) - -0.047068208364958584) / 0.5338412523843211 + \
                 -0.31922438740730286 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) * (cos(AB/6.7*pi/2.0)) - -0.024533058035904626) / 0.3227320389025673 + \
                 0.0010429008398205042

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order2(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.6865623593330383 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.45387721061706543 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             0.0028171397279947996
        AY = 0.3237815499305725 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             -0.4057817757129669 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.0018969750963151455
        ATHETA = 0.7847346067428589 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 -0.7363168001174927 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.0027397561352699995
        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order3(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5994749665260315 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.10300672054290771 * (np.power(2,AB) - 1.2063352407160353) / 0.7105174540771907 + \
             0.4622511863708496 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             0.003422610694542527

        AY = 0.5038067102432251 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             -0.20719482004642487 * ((VY) * (cos(VX/10.0*pi/2.0)) - -0.003216463910703705) / 0.21981376130711971 + \
             -0.5739778280258179 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.00254575302824378

        ATHETA = 0.9858863353729248 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 -0.4723876118659973 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
                 -0.4995514154434204 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.0012328726006671786

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order4(self, features):
        #2nd term in AY is baaaad!
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5805888772010803 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.3011525273323059 * (np.power(2,AB) - 1.2063352407160353) / 0.7105174540771907 + \
             0.4603855013847351 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             -0.18075908720493317 * ((np.power(2,AB)) * (cos(TV/2.1*pi/2.0)) - 1.1059169148482064) / 0.7502383658131054 + \
             0.0030882766004651785

        AY = 0.484951913356781 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             0.3021593391895294 * (VY - 0.0006739826858158322) / 0.3073995994274385 + \
             -0.4827837646007538 * ((VY) * (cos(VX/10.0*pi/2.0)) - -0.003216463910703705) / 0.21981376130711971 + \
             -0.5156410932540894 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.0022277936805039644

        ATHETA = 0.43768614530563354 * ((VX) * (BETA) - -0.059164368850320524) / 0.616404092345298 + \
                 0.5743695497512817 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 -0.5102530121803284 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
                 -0.4826582372188568 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.0009870609501376748

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order34(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5805888772010803 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.3011525273323059 * (np.power(2, AB) - 1.2063352407160353) / 0.7105174540771907 + \
             0.4603855013847351 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             -0.18075908720493317 * ((np.power(2, AB)) * (cos(TV / 2.1 * pi / 2.0)) - 1.1059169148482064) / 0.7502383658131054 + \
             0.0030882766004651785

        AY = 0.5038067102432251 * ((VTHETA) * (cos(VX / 10.0 * pi / 2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             -0.20719482004642487 * ((VY) * (cos(VX / 10.0 * pi / 2.0)) - -0.003216463910703705) / 0.21981376130711971 + \
             -0.5739778280258179 * ((VTHETA) * (sin(VX / 10.0 * pi / 2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.00254575302824378

        ATHETA = 0.43768614530563354 * ((VX) * (BETA) - -0.059164368850320524) / 0.616404092345298 + \
                 0.5743695497512817 * ((VX) * (sin(BETA / 0.44 * pi / 2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 -0.5102530121803284 * ((VTHETA) * (cos(VX / 10.0 * pi / 2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
                 -0.4826582372188568 * ((VTHETA) * (cos(BETA / 0.44 * pi / 2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.0009870609501376748

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order5(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.5846104621887207 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.4415443539619446 * (np.power(2,AB) - 1.2063352407160353) / 0.7105174540771907 + \
             0.43256452679634094 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             -0.2898644506931305 * ((np.power(2,AB)) * (cos(TV/2.1*pi/2.0)) - 1.1059169148482064) / 0.7502383658131054 + \
             -0.11308101564645767 * ((cos(AB/6.7*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - 0.2988186821761009) / 0.2425852112265329 + \
             0.0035051375161856413

        AY = 0.2716746926307678 * ((VTHETA) * (np.power(2,AB)) - -0.0232559976392174) / 0.9453828498950136 + \
             0.37222230434417725 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             0.27636396884918213 * (VY - 0.0006739826858158322) / 0.3073995994274385 + \
             -0.44212478399276733 * ((VY) * (cos(VX/10.0*pi/2.0)) - -0.003216463910703705) / 0.21981376130711971 + \
             -0.6415807008743286 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.0018424561712890863

        ATHETA = 0.3766404986381531 * ((VX) * (BETA) - -0.059164368850320524) / 0.616404092345298 + \
                 0.4444778859615326 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 0.32012638449668884 * ((TV) * (tan(VX/10.0*pi/3.0)) - -0.028058412762629863) / 0.3280168713316988 + \
                 -0.4642033874988556 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
                 -0.5562203526496887 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.00185977085493505

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()

    def NN_poly2_order6(self, features):
        if isinstance(features, list):
            VX, VY, VTHETA, BETA, AB, TV = features[0]
            VX, VY, VTHETA, BETA, AB, TV = float(VX), float(VY), float(VTHETA), float(BETA), float(AB), float(TV)
        else:
            VX = features[:, 0]
            VY = features[:, 1]
            VTHETA = features[:, 2]
            BETA = features[:, 3]
            AB = features[:, 4]
            TV = features[:, 5]
        AX = 0.6003774404525757 * (AB - 0.06560439433747117) / 0.837672127818587 + \
             0.4249855875968933 * (np.power(2,AB) - 1.2063352407160353) / 0.7105174540771907 + \
             0.25299155712127686 * ((VX) * (cos(BETA/0.44*pi/2.0)) - 2.086206577040916) / 1.7625891197618575 + \
             0.4387243986129761 * ((VY) * (VTHETA) - -0.0075517562606167935) / 0.4547007200691509 + \
             -0.3061627447605133 * ((np.power(2,AB)) * (cos(TV/2.1*pi/2.0)) - 1.1059169148482064) / 0.7502383658131054 + \
             -0.30093860626220703 * ((cos(AB/6.7*pi/2.0)) * (tan(VX/10.0*pi/3.0)) - 0.2988186821761009) / 0.2425852112265329 + \
             0.0031248026061803102

        AY = 0.294514000415802 * ((VTHETA) * (np.power(2,AB)) - -0.0232559976392174) / 0.9453828498950136 + \
             0.46538349986076355 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
             0.28190743923187256 * (VY - 0.0006739826858158322) / 0.3073995994274385 + \
             -0.23176391422748566 * ((sin(VX/10.0*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.02448072465955652) / 0.2542822057050383 + \
             -0.3877294957637787 * ((VY) * (cos(VX/10.0*pi/2.0)) - -0.003216463910703705) / 0.21981376130711971 + \
             -0.5363277792930603 * ((VTHETA) * (sin(VX/10.0*pi/2.0)) - -0.026079669151949817) / 0.3637920253275057 + \
             0.002315372694283724

        ATHETA = 0.36890795826911926 * ((VX) * (BETA) - -0.059164368850320524) / 0.616404092345298 + \
                 0.39902248978614807 * ((VX) * (sin(BETA/0.44*pi/2.0)) - -0.1780450110006059) / 1.8442130252282332 + \
                 0.3256327211856842 * ((TV) * (tan(VX/10.0*pi/3.0)) - -0.028058412762629863) / 0.3280168713316988 + \
                 0.14809702336788177 * ((cos(BETA/0.44*pi/2.0)) * (tan(BETA/0.44*pi/3.0)) - -0.04171116101243709) / 0.2943814825202627 + \
                 -0.503495454788208 * ((VTHETA) * (cos(VX/10.0*pi/2.0)) - -0.03558960931344437) / 0.41623512135178375 + \
                 -0.5909506678581238 * ((VTHETA) * (cos(BETA/0.44*pi/2.0)) - -0.024989885213979424) / 0.33482893553899584 + \
                 0.001512077753432095

        if isinstance(features,list):
            return [AX, AY, ATHETA]
        else:
            return np.array([AX, AY, ATHETA]).transpose()
